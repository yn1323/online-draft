import{c as W}from"./factory-4NXM9rHI.js";import{a1 as X,a2 as z,a3 as w}from"./index-By25cWhp.js";import{b as Y,J as Z,K as h,G as T,w as H,L as tt,H as et}from"./index-JKOH53Am.js";import{r as s}from"./index-BXymfbzT.js";import{r as rt}from"./index-DGKHe-6Q.js";import{a as nt}from"./index-CrjboX4Z.js";import"./create-recipe-context-oy0ofMwS.js";const[Rt,pt]=W({name:"LocaleContext",hookName:"useLocaleContext",providerName:"<LocaleProvider />",strict:!1,defaultValue:{dir:"ltr",locale:"en-US"}});var J=rt(),U=typeof globalThis.document<"u"?s.useLayoutEffect:s.useEffect;function k(t){const o=t().value??t().defaultValue,a=t().isEqual??Object.is,[i]=s.useState(o),[S,y]=s.useState(i),M=t().value!==void 0,x=s.useRef(S);x.current=M?t().value:S;const b=s.useRef(x.current);U(()=>{b.current=x.current},[S,t().value]);const E=g=>{var m,N;const f=b.current,l=T(g)?g(f):g;t().debug&&console.log(`[bindable > ${t().debug}] setValue`,{next:l,prev:f}),M||y(l),a(l,f)||(N=(m=t()).onChange)==null||N.call(m,l,f)};function q(){return M?t().value:S}return{initial:i,ref:x,get:q,set(g){(t().sync?J.flushSync:h)(()=>E(g))},invoke(g,f){var l,m;(m=(l=t()).onChange)==null||m.call(l,g,f)},hash(g){var f,l;return((l=(f=t()).hash)==null?void 0:l.call(f,g))??String(g)}}}k.cleanup=t=>{s.useEffect(()=>t,[])};k.ref=t=>{const o=s.useRef(t);return{get:()=>o.current,set:a=>{o.current=a}}};function ut(t){const o=s.useRef(t);return{get(a){return o.current[a]},set(a,i){o.current[a]=i}}}var st=(t,o)=>{const a=s.useRef(!1),i=s.useRef(!1);s.useEffect(()=>{if(a.current&&i.current)return o();i.current=!0},[...(t??[]).map(S=>typeof S=="function"?S():S)]),s.useEffect(()=>(a.current=!0,()=>{a.current=!1}),[])};function St(t,o={}){var I,P,B,G;const a=s.useMemo(()=>{const{id:r,ids:e,getRootNode:n}=o;return X({id:r,ids:e,getRootNode:n})},[o]),i=(...r)=>{t.debug&&console.log(...r)},S=((I=t.props)==null?void 0:I.call(t,{props:Y(o),scope:a}))??o,y=ot(S),M=(P=t.context)==null?void 0:P.call(t,{prop:y,bindable:k,scope:a,flush:K,getContext(){return b},getComputed(){return j},getRefs(){return N}}),x=_(M),b={get(r){var e;return(e=x.current)==null?void 0:e[r].ref.current},set(r,e){var n;(n=x.current)==null||n[r].set(e)},initial(r){var e;return(e=x.current)==null?void 0:e[r].initial},hash(r){var n,u;const e=(n=x.current)==null?void 0:n[r].get();return(u=x.current)==null?void 0:u[r].hash(e)}},E=s.useRef(new Map),q=s.useRef(null),g=s.useRef(null),f=s.useRef({type:""}),l=()=>({...f.current,current(){return f.current},previous(){return g.current}}),m=()=>({...R,matches(...r){return r.includes(R.ref.current)},hasTag(r){var e,n;return!!((n=(e=t.states[R.ref.current])==null?void 0:e.tags)!=null&&n.includes(r))}}),N=ut(((B=t.refs)==null?void 0:B.call(t,{prop:y,context:b}))??{}),C=()=>({state:m(),context:b,event:l(),prop:y,send:F,action:L,guard:O,track:st,refs:N,computed:j,flush:K,scope:a,choose:A}),L=r=>{const e=T(r)?r(C()):r;if(!e)return;const n=e.map(u=>{var d,v;const c=(v=(d=t.implementations)==null?void 0:d.actions)==null?void 0:v[u];return c||H(`[zag-js] No implementation found for action "${JSON.stringify(u)}"`),c});for(const u of n)u==null||u(C())},O=r=>{var e,n;return T(r)?r(C()):(n=(e=t.implementations)==null?void 0:e.guards)==null?void 0:n[r](C())},$=r=>{const e=T(r)?r(C()):r;if(!e)return;const n=e.map(c=>{var v,p;const d=(p=(v=t.implementations)==null?void 0:v.effects)==null?void 0:p[c];return d||H(`[zag-js] No implementation found for effect "${JSON.stringify(c)}"`),d}),u=[];for(const c of n){const d=c==null?void 0:c(C());d&&u.push(d)}return()=>u.forEach(c=>c==null?void 0:c())},A=r=>tt(r).find(e=>{let n=!e.guard;return et(e.guard)?n=!!O(e.guard):T(e.guard)&&(n=e.guard(C())),n}),j=r=>{Z(t.computed,()=>"[zag-js] No computed object found on machine");const e=t.computed[r];return e({context:b,event:l(),prop:y,refs:N,scope:a,computed:j})},R=k(()=>({defaultValue:t.initialState({prop:y}),onChange(r,e){var u,c,d,v;if(e){const p=E.current.get(e);p==null||p(),E.current.delete(e)}e&&L((u=t.states[e])==null?void 0:u.exit),L((c=q.current)==null?void 0:c.actions);const n=$((d=t.states[r])==null?void 0:d.effects);if(n&&E.current.set(r,n),e===w){L(t.entry);const p=$(t.effects);p&&E.current.set(w,p)}L((v=t.states[r])==null?void 0:v.entry)}})),D=s.useRef(void 0),V=s.useRef(z.NotStarted);U(()=>{queueMicrotask(()=>{const n=V.current===z.Started;V.current=z.Started,i(n?"rehydrating...":"initializing...");const u=D.current??R.initial;R.invoke(u,n?R.get():w)});const r=E.current,e=R.ref.current;return()=>{i("unmounting..."),D.current=e,V.current=z.Stopped,r.forEach(n=>n==null?void 0:n()),E.current=new Map,q.current=null,queueMicrotask(()=>{L(t.exit)})}},[]);const Q=()=>"ref"in R?R.ref.current:R.get(),F=r=>{queueMicrotask(()=>{var v,p;if(V.current!==z.Started)return;g.current=f.current,f.current=r,i("send",r);let e=Q();const n=((v=t.states[e].on)==null?void 0:v[r.type])??((p=t.on)==null?void 0:p[r.type]),u=A(n);if(!u)return;q.current=u;const c=u.target??e;i("transition",u);const d=c!==e;d?J.flushSync(()=>R.set(c)):u.reenter&&!d?R.invoke(e,e):L(u.actions??[])})};return(G=t.watch)==null||G.call(t,C()),{state:m(),send:F,context:b,prop:y,scope:a,refs:N,computed:j,event:l(),getStatus:()=>V.current}}function _(t){const o=s.useRef(t);return o.current=t,o}function ot(t){const o=_(t);return function(i){return o.current[i]}}function K(t){queueMicrotask(()=>{J.flushSync(()=>t())})}var vt=nt(t=>t);export{St as a,vt as n,J as r,pt as u};
