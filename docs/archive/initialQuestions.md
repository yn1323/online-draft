# コーディング規約策定 Q&A

このファイルは OnlineDraft プロジェクトのコーディング規約を対話形式で策定するための質問集です。
回答は各Questionの下に記載します。
回答の冒頭の数字が大きいほど開発者の中で重要度が高いです。(最大5、最小0)

## 🏗️ アーキテクチャ・設計思想

### コンポーネント設計哲学
- **Q1**: 単一責任の原則をどこまで厳密に適用しますか？（厳格 vs 実用的バランス）
- **Q2**: props drilling vs context使用の判断基準は何ですか？
- **Q3**: コンポーネントの抽象化レベルをどう決めますか？（具体的 vs 汎用的）
- **Q4**: 再利用性 vs 特化性のバランスはどう取りますか？
- **Q5**: Higher-Order Components vs Custom Hooks vs Render Props の使い分けは？

### 状態管理設計思想
- **Q6**: ローカル状態 vs グローバル状態の境界線は何ですか？
- **Q7**: Jotaiアトムの粒度をどう決めますか？（細分化 vs 統合）
- **Q8**: 状態の正規化 vs 非正規化の判断基準は？
- **Q9**: 楽観的更新 vs 悲観的更新の使い分けは？
- **Q10**: 状態の永続化戦略（SessionStorage vs LocalStorage vs Firebase）は？

### レイヤー分離・依存関係
- **Q11**: ビジネスロジックとUIロジックの分離方針は？
- **Q12**: サービス層の責任範囲をどこまでにしますか？
- **Q13**: 循環依存を防ぐための構造ルールは？
- **Q14**: 外部APIとの結合度をどう管理しますか？

## 📝 コーディングスタイル・実装パターン

### 関数・メソッドの実装パターン
- **Q15**: Arrow Function vs Function Declaration の使い分けは？
- **Q16**: 関数の引数が多い時（3個以上）の対処法は？（オブジェクト化 vs 個別引数）
- **Q17**: 関数の戻り値の型注釈は明示的 vs 推論どちらを好みますか？
- **Q18**: Early Return vs ネストした条件分岐どちらを好みますか？
- **Q19**: 複雑な条件式の書き方（三項演算子 vs if文 vs switch文）は？

### 変数・定数の宣言スタイル
- **Q20**: const vs let の使い分け基準は？
- **Q21**: 変数名の長さの好み（短縮 vs 説明的）は？
- **Q22**: 分割代入をどこまで積極的に使いますか？
- **Q23**: オブジェクトの初期化パターン（空オブジェクト vs 全プロパティ指定）は？
- **Q24**: 配列操作の好み（for loop vs forEach vs map/filter/reduce）は？

### 非同期処理の実装パターン
- **Q25**: async/await vs Promise.then() の使い分けは？
- **Q26**: 複数の非同期処理の並列実行（Promise.all vs 個別await）は？
- **Q27**: エラーハンドリング（try-catch vs .catch()）の好みは？
- **Q28**: ローディング状態の管理パターンは？
- **Q29**: 非同期処理のキャンセレーション実装は？

## ⚛️ React特有の実装スタイル

### コンポーネント定義パターン
- **Q30**: React.FC vs 通常の関数コンポーネントどちらを好みますか？
- **Q31**: Propsの型定義（interface vs type）の使い分けは？
- **Q32**: デフォルトPropsの実装方法（デフォルト引数 vs defaultProps）は？
- **Q33**: 条件付きレンダリング（&& vs 三項演算子 vs if文）の好みは？
- **Q34**: コンポーネント内の関数定義（useCallback必須 vs 必要時のみ）は？

### Hooks使用パターン
- **Q35**: useState vs useReducer の使い分け基準は？
- **Q36**: useEffect内の依存配列の書き方（全依存 vs 最小限）は？
- **Q37**: カスタムフックの分離タイミングは？
- **Q38**: useMemory/useCallback の使用基準（積極的 vs 慎重）は？
- **Q39**: ref使用時（useRef vs createRef）の好みは？

## 🆕 React 19・Next.js 15特化戦略

### React 19 新機能活用
- **Q40**: `use()` Hook の使用範囲（Promise vs Context vs どちらも）は？
- **Q41**: `startTransition()` の使用基準（重い処理 vs UI更新 vs 両方）は？
- **Q42**: `useDeferredValue()` vs `useTransition()` の使い分けは？
- **Q43**: Suspense境界の配置戦略（コンポーネント単位 vs ページ単位 vs 機能単位）は？
- **Q44**: `<Suspense>` fallback UI の詳細度（スケルトン vs スピナー vs カスタム）は？
- **Q45**: Concurrent Rendering での状態管理注意点は？

### Next.js App Router運用
- **Q46**: Server Components使用の最大化度（可能な限り vs 必要時のみ）は？
- **Q47**: Client Components化の判断基準（state使用 vs イベント使用 vs ブラウザAPI）は？
- **Q48**: 'use client' 配置の粒度（ファイル先頭 vs 必要最小限のコンポーネント）は？
- **Q49**: Server/Client境界でのdata passing最適化は？
- **Q50**: Client Components内でのServer Components children pattern使用は？

### キャッシュ・レンダリング戦略
- **Q51**: Static Generation vs Server-Side Rendering の使い分けは？
- **Q52**: ISR (Incremental Static Regeneration) 使用の基準は？
- **Q53**: revalidate設定の粒度（ページ別 vs 機能別 vs 統一）は？
- **Q54**: Data Cache vs Full Route Cache の使い分けは？
- **Q55**: Edge Runtime vs Node.js Runtime の選択基準は？

## 🔤 命名規則・ファイル構成

### 命名パターンの一貫性
- **Q56**: boolean値の命名規則（is/has/can/should prefix）は？
- **Q57**: イベントハンドラーの命名パターン（handle/on prefix）は？
- **Q58**: 定数の命名規則（SCREAMING_SNAKE vs PascalCase）は？
- **Q59**: 型名の接尾辞（Type/Interface/Props/State）は？
- **Q60**: カスタムフックの命名規則（use prefix以外の制約）は？

### ファイル・ディレクトリ構成哲学
- **Q61**: feature-first vs type-first どちらを優先しますか？
- **Q62**: index.tsファイルの使用方針は？
- **Q63**: テストファイルの配置（同階層 vs __tests__ディレクトリ）は？
- **Q64**: ユーティリティ関数の分類基準は？
- **Q65**: 共通コンポーネントの昇格タイミングは？

## 🔧 TypeScript活用方針

### 型安全性のレベル設定
- **Q66**: strict modeの各オプションをどこまで有効にしますか？
- **Q67**: any使用の例外ケースと代替手段は？
- **Q68**: unknown vs any の使い分けは？
- **Q69**: 型アサーションの使用ガイドラインは？
- **Q70**: 型ガードの実装パターンは？

### 型定義の組織化戦略
- **Q71**: Domain types vs UI types の分離方針は？
- **Q72**: 型の再利用 vs 特化の判断基準は？
- **Q73**: ジェネリクス使用の複雑さの上限は？
- **Q74**: 条件型やmapped typesの使用方針は？
- **Q75**: 型定義ファイルの粒度は？

### TypeScript実装の詳細
- **Q76**: 型エイリアス vs インターフェースの使い分けは？
- **Q77**: Optional vs Required プロパティの設計方針は？
- **Q78**: Union Types vs Enum の使い分けは？
- **Q79**: ジェネリクスの命名規則（T vs 説明的名前）は？
- **Q80**: 型ガードの実装パターン（user-defined type guards vs in演算子）は？

## 🧪 テスト戦略・品質保証

### E2Eテスト運用詳細
- **Q81**: E2Eテストの実行頻度（毎commit vs 毎PR vs 毎リリース）は？
- **Q82**: テストシナリオの粒度（ハッピーパス vs エッジケース比率）は？
- **Q83**: テストデータ管理（固定 vs 動的生成 vs 本番データコピー）は？
- **Q84**: 並列実行時の分離度（完全独立 vs 部分共有）は？
- **Q85**: 失敗時のデバッグ情報保存レベル（スクリーンショット vs 動画 vs DOM状態）は？
- **Q86**: cross-browser テストの対象範囲（Chrome only vs Multi-browser）は？
- **Q87**: モバイル端末テストの実装度は？

### VRT (Visual Regression Testing) 運用
- **Q88**: スクリーンショット比較の閾値設定（ピクセル単位 vs パーセンテージ）は？
- **Q89**: レスポンシブ対応のテスト範囲（デスクトップ vs タブレット vs モバイル）は？
- **Q90**: ダークモード vs ライトモードの両方テストしますか？
- **Q91**: アニメーション中の状態キャプチャ方針は？
- **Q92**: フォント・ブラウザ差分の許容レベルは？
- **Q93**: VRT失敗時の承認プロセス（自動更新 vs 手動確認）は？
- **Q94**: Storybook統合レベル（全Story vs 重要Storyのみ）は？

### Storybook品質戦略
- **Q95**: Story作成の義務レベル（全Component必須 vs 主要のみ）は？
- **Q96**: Story variants の網羅度（全Props組み合わせ vs 代表的パターン）は？
- **Q97**: Interactive testing の実装度（クリック vs フォーム入力 vs 複雑操作）は？
- **Q98**: A11y addon の活用レベル（基本チェック vs 詳細検証）は？
- **Q99**: Design token との同期度（手動 vs 自動更新）は？
- **Q100**: Storybook デプロイ頻度（開発時のみ vs 本番公開）は？

### テストケース設計思想
- **Q101**: Happy Path vs Edge Case のテスト比重は？
- **Q102**: Mock使用の積極度（最小限 vs 広範囲）は？
- **Q103**: テストデータの準備方法（ファクトリー vs インライン）は？
- **Q104**: アサーションの詳細度（厳密 vs 必要最小限）は？
- **Q105**: テスト名の命名パターン（日本語 vs 英語, describe文の構成）は？

## 🎨 UI/UX設計・実装方針

### デザインシステム・コンポーネント設計
- **Q106**: Atomic Design の厳密度（厳格分類 vs 柔軟運用）は？
- **Q107**: コンポーネントAPI設計の一貫性レベル（props命名統一度）は？
- **Q108**: バリアント vs 個別コンポーネントの判断基準は？
- **Q109**: Compound Component pattern の使用度は？
- **Q110**: スタイルprops vs styled-component の使い分けは？
- **Q111**: カスタムフックでのUI状態管理範囲は？

### レスポンシブ・アダプティブデザイン
- **Q112**: ブレイクポイント設計の詳細度（5段階 vs 3段階 vs 2段階）は？
- **Q113**: モバイルファースト vs デスクトップファーストどちらを基準にしますか？
- **Q114**: タッチデバイス対応の詳細度（タップエリアサイズ vs ジェスチャー対応）は？
- **Q115**: フォールバック対応の範囲（古いブラウザサポート度）は？
- **Q116**: 画面回転対応の必要性は？

### インタラクション・アニメーション設計
- **Q117**: アニメーション duration の統一基準（150ms vs 300ms vs 状況別）は？
- **Q118**: イージング関数の使い分け（ease vs ease-in-out vs cubic-bezier）は？
- **Q119**: ローディング状態の表現詳細度（スピナー vs スケルトン vs プログレスバー）は？
- **Q120**: hover/focus状態の一貫性レベルは？
- **Q121**: マイクロインタラクションの実装度（ボタン押下感 vs フォーム入力フィードバック）は？
- **Q122**: reduced-motion 対応の詳細度は？

### Chakra UI使用パターン
- **Q123**: inline style props vs sx props の使い分けは？
- **Q124**: カスタムコンポーネントのスタイル継承方法は？
- **Q125**: レスポンシブ対応の書き方（配列記法 vs オブジェクト記法）は？
- **Q126**: テーマのカスタマイズレベル（最小限 vs 大幅カスタム）は？
- **Q127**: アニメーション実装（Framer Motion vs CSS Transition）の好みは？

## ⚡ パフォーマンス・最適化戦略

### Core Web Vitals 具体的目標値
- **Q128**: LCP (Largest Contentful Paint) 目標値（1.2s vs 2.5s）は？
- **Q129**: FID (First Input Delay) 許容値（100ms vs 300ms）は？
- **Q130**: CLS (Cumulative Layout Shift) 閾値（0.1 vs 0.25）は？
- **Q131**: INP (Interaction to Next Paint) 目標値は？
- **Q132**: TTFB (Time to First Byte) 許容値は？

### React最適化
- **Q133**: `React.memo()` 使用の判断基準（全コンポーネント vs 重いコンポーネントのみ）は？
- **Q134**: `useMemo()` / `useCallback()` の使用基準（積極的 vs 測定後 vs プロファイル後）は？
- **Q135**: `useRef()` vs `useState()` の使い分け（DOM参照 vs 値保持 vs タイマー管理）は？
- **Q136**: Context分割の粒度（機能別 vs データ別 vs パフォーマンス別）は？
- **Q137**: Re-render最適化の優先度（開発速度 vs パフォーマンス）は？

### リソース最適化
- **Q138**: 画像最適化の自動化度（WebP変換 vs AVIF対応 vs サイズ別最適化）は？
- **Q139**: フォント最適化（subset vs display:swap vs preload）の方針は？
- **Q140**: JavaScript bundle サイズ制限（initial vs chunk単位）は？
- **Q141**: CSS最適化レベル（Critical CSS vs 全CSS最適化）は？
- **Q142**: Third-party script の管理方針（最小限 vs 必要時許可）は？

### Next.js最適化
- **Q143**: next/image 最適化設定（quality vs size vs format）の詳細は？
- **Q144**: next/font 使用方針（Google Fonts vs Local Fonts vs Variable Fonts）は？
- **Q145**: Bundle Analyzer使用頻度（毎ビルド vs 定期 vs 問題発生時）は？
- **Q146**: Code Splitting粒度（ページ単位 vs 機能単位 vs コンポーネント単位）は？
- **Q147**: Third-party Scripts最適化（next/script strategy設定）は？
- **Q148**: Prefetching設定（aggressive vs conservative vs disabled）の方針は？

## 🔄 CI/CD・開発プロセス運用

### CI監視・対応方針
- **Q149**: CI失敗時の対応速度要件（即座 vs 1時間以内 vs 日内）は？
- **Q150**: テスト失敗 vs ビルド失敗 vs Lint失敗の重要度は？
- **Q151**: フレーキーテストの対処方針（即修正 vs 一時無効化）は？
- **Q152**: CI実行時間の許容上限（5分 vs 10分 vs 制限なし）は？
- **Q153**: 並列実行 vs 直列実行の判断基準は？

### ブランチ戦略・Git運用
- **Q154**: Git Flow vs GitHub Flow vs GitLab Flow どれを採用しますか？
- **Q155**: feature branch の粒度（機能単位 vs タスク単位）は？
- **Q156**: 長期ブランチの運用方針（develop branch必要性）は？
- **Q157**: マージ方式（Merge commit vs Squash vs Rebase）の使い分けは？
- **Q158**: Conflict解決の責任者（feature作成者 vs レビュアー）は？

### コミット・PR運用
- **Q159**: コミットメッセージの詳細度（Conventional Commits準拠度）は？
- **Q160**: PRサイズの制限（行数 vs ファイル数 vs 概念単位）は？
- **Q161**: レビュアー指定方針（自動割当 vs 手動選択）は？
- **Q162**: レビュー完了基準（Approve数 vs 特定人承認）は？
- **Q163**: Draft PR の活用度（WIP共有 vs 完成後のみ）は？

### デプロイ・リリース戦略
- **Q164**: Feature Flag使用方針（積極活用 vs 最小限）は？
- **Q165**: ロールバック基準・手順の詳細度は？
- **Q166**: カナリアリリース vs Blue-Green vs Rolling deployment選択は？
- **Q167**: 本番データベースマイグレーション戦略は？
- **Q168**: ホットフィックスのプロセス（緊急度別対応）は？

## 💳 技術的負債・保守性管理

### 負債の分類・優先順位
- **Q169**: 設計負債 vs コード負債 vs テスト負債 vs ドキュメント負債の重み付けは？
- **Q170**: 負債の可視化方法（TODO/FIXME/HACK コメント vs Issue管理）は？
- **Q171**: 負債解消のスプリント内時間配分（新機能 vs リファクタリング比率）は？
- **Q172**: レガシーコード改善の判断基準（全書き換え vs 段階改修）は？
- **Q173**: 外部依存関係の更新頻度・方針は？

### コード品質維持戦略
- **Q174**: 複雑度指標の監視レベル（Cyclomatic Complexity閾値）は？
- **Q175**: デッドコードの検出・削除頻度は？
- **Q176**: 重複コードの許容レベルは？
- **Q177**: コメント品質の維持方針（量 vs 質）は？

## 📊 監視・ログ・運用戦略

### エラー監視・対応
- **Q178**: エラー率の許容閾値（0.1% vs 1% vs 5%）は？
- **Q179**: アラート設定の粒度（即座通知 vs 集約通知）は？
- **Q180**: ログレベルの運用（本番DEBUG必要性）は？
- **Q181**: パフォーマンス劣化の検知基準（応答時間 vs スループット）は？
- **Q182**: ユーザー行動分析の詳細度は？

### セキュリティ・コンプライアンス
- **Q183**: 依存関係脆弱性の対応速度（Critical即座 vs 週次確認）は？
- **Q184**: 個人情報取扱の厳密度（最小限 vs 利便性重視）は？
- **Q185**: 認証トークンの有効期限設定は？
- **Q186**: HTTPS強制レベル（全強制 vs 部分許可）は？
- **Q187**: セキュリティヘッダーの設定詳細度は？

## 🎯 エラーハンドリング・信頼性

### React・Next.js エラー対応
- **Q188**: Error Boundary配置戦略（Global vs Page vs Component）は？
- **Q189**: Server-side Error vs Client-side Error の処理方針は？
- **Q190**: Error reporting（Sentry vs 自前 vs 組み合わせ）の詳細度は？
- **Q191**: 404・500エラーページのカスタマイズレベルは？
- **Q192**: ハイドレーションエラー対策の詳細度は？

### セキュリティ対策
- **Q193**: XSS対策の詳細度（CSP vs Sanitization vs 両方）は？
- **Q194**: CSRF対策（Next.js内蔵 vs 追加対策）の必要性は？
- **Q195**: Security Headers設定（next.config.ts vs Middleware）の詳細は？
- **Q196**: API Routes認証・認可の詳細設計は？
- **Q197**: Client-side secrets管理の厳密度は？

## 🗃️ データ処理・状態管理

### Jotai使用パターン
- **Q198**: Atomの分割粒度（細分化 vs 統合）の好みは？
- **Q199**: Derived atomsの使用頻度は？
- **Q200**: Atom with storageの活用範囲は？
- **Q201**: Async atomsのエラーハンドリングパターンは？
- **Q202**: Atomの命名規則（接尾辞Atom必須 vs 自由）は？

### Firebase連携パターン
- **Q203**: Firestore クエリの最適化レベルは？
- **Q204**: リアルタイム更新 vs 手動更新の使い分けは？
- **Q205**: オフライン対応の実装度は？
- **Q206**: セキュリティルールの厳密さレベルは？
- **Q207**: バッチ処理 vs 個別処理の判断基準は？

### 状態管理品質保証
- **Q208**: 状態の整合性チェック頻度（リアルタイム vs 定期 vs 手動）は？
- **Q209**: 楽観的更新失敗時のロールバック詳細度は？
- **Q210**: オフライン時のデータ同期戦略は？
- **Q211**: データ重複指名状態の検出・解決方針は？
- **Q212**: 状態のバリデーション実装度（型レベル vs ランタイム vs ビジネスルール）は？

## 🌐 アクセシビリティ・国際化

### アクセシビリティ対応
- **Q213**: WCAG準拠レベル（AA vs AAA）の目標は？
- **Q214**: キーボードナビゲーション対応の詳細度（Tab順序 vs ショートカット vs カスタム操作）は？
- **Q215**: スクリーンリーダー対応（aria-label vs aria-describedby vs 構造的マークアップ）の詳細度は？
- **Q216**: 色覚多様性対応（色のみ情報伝達禁止 vs アイコン併用 vs パターン使用）は？
- **Q217**: フォントサイズ・行間設定の柔軟度（ユーザー設定尊重度）は？
- **Q218**: 音声・動画コンテンツの代替手段提供度は？

### 認知アクセシビリティ・ユーザビリティ
- **Q219**: エラーメッセージの明確度（技術的 vs ユーザーフレンドリー）は？
- **Q220**: 操作の取り消し可能度（アンドゥ機能 vs 確認ダイアログ）は？
- **Q221**: 情報構造の分かりやすさ（階層表現 vs フラット表現）は？
- **Q222**: 認知負荷軽減の工夫レベル（段階的開示 vs 一覧表示）は？

### 国際化・ローカライゼーション
- **Q223**: 国際化対応の準備度（将来対応 vs 現在必須）は？
- **Q224**: 翻訳キー管理の粒度（単語単位 vs 文章単位 vs 文脈単位）は？
- **Q225**: 動的コンテンツの翻訳対応（リアルタイム vs 事前翻訳）は？
- **Q226**: 数値・日付・通貨フォーマットの地域対応度は？
- **Q227**: RTL言語対応の準備度（レイアウト vs アイコン vs アニメーション）は？
- **Q228**: フォント対応の国際化度（日本語 vs 中国語 vs アラビア語等）は？

## 🛠️ 開発環境・ツール統一

### IDE・エディタ設定
- **Q229**: VSCode拡張機能の推奨・必須レベルは？
- **Q230**: Formatter設定の統一度（Prettier vs Biome設定詳細）は？
- **Q231**: Linter厳密度（Error vs Warning境界）は？
- **Q232**: デバッガー使用 vs console.log デバッグの方針は？

### 開発効率・自動化
- **Q233**: コード生成ツール（Copilot等）の活用方針は？
- **Q234**: テンプレート・スニペット標準化度は？
- **Q235**: 開発サーバー起動時間の許容上限は？
- **Q236**: ホットリロード vs フルリロードの判断基準は？

### 開発体験品質
- **Q237**: 開発サーバー起動時間の目標値（3秒 vs 10秒 vs 制限なし）は？
- **Q238**: ホットリロード性能の許容値（変更検知速度）は？
- **Q239**: TypeScript型チェック速度の目標値は？
- **Q240**: Linting・Formatting実行速度の許容値は？
- **Q241**: ビルド時間の目標値（本番ビルド vs 開発ビルド）は？

### デバッグ・トラブルシューティング
- **Q242**: エラーメッセージの詳細度（スタックトレース vs 原因説明）は？
- **Q243**: 開発時ログの出力レベル（詳細 vs 必要最小限）は？
- **Q244**: デバッグツール統合度（React DevTools vs Redux DevTools等）は？
- **Q245**: パフォーマンス分析ツールの活用度は？

## 📚 ドキュメント・ナレッジ管理

### 技術文書戦略
- **Q246**: API仕様書の詳細度（OpenAPI完全準拠度）は？
- **Q247**: アーキテクチャ図の更新頻度は？
- **Q248**: 運用手順書の粒度（ステップバイステップ詳細度）は？
- **Q249**: 障害対応手順の文書化レベルは？

### 知識共有・オンボーディング
- **Q250**: 新メンバー向け教育資料の充実度は？
- **Q251**: 技術選定理由の文書化義務は？
- **Q252**: 設計判断の記録保持期間は？
- **Q253**: コードコメント vs 外部文書の使い分けは？

## 🔮 将来対応・拡張性

### アーキテクチャ拡張性
- **Q254**: Micro-frontends対応の準備度は？
- **Q255**: Multi-tenant対応の考慮度は？
- **Q256**: 大規模チーム開発対応（モノレポ vs マルチレポ）は？
- **Q257**: React Server Components進化への追従方針は？
- **Q258**: Next.js新機能導入の積極度は？

### パフォーマンス・スケーラビリティ対応
- **Q259**: 大量データ表示時の仮想化戦略は？
- **Q260**: リアルタイム機能のスケーリング対応は？
- **Q261**: Global State肥大化対策は？
- **Q262**: Component tree深度の管理方針は？
- **Q263**: Memory leak防止の詳細対策は？
